#This script is used to loop through all fastq files in a folder and extract read ids for Allele_1 and Allele_2 with matching polymorphic segment of the CTC motif. The read ids are saved to separate text files with r2_allele_1_ctc and r2_allele_2_ctc suffixes based on the CTC count. The script also displays the numbers after CTC in r2_allele_1_ctc and r2_allele_2_ctc columns for each fastq file. 
#!/bin/bash
 
# Input folder for fastq files
input_folder="/Users/shane/Library/CloudStorage/OneDrive-UniversityCollegeLondon/Medicine/Ophthalmology_ST/PhD/MiSeq/DoubleExpanded/RawData"
 
# Reference list CSV file. This file contains the sample_key, r2_allele_1_ctc and r2_allele_2_ctc columns.
reference_list="/Users/shane/Library/CloudStorage/OneDrive-UniversityCollegeLondon/Medicine/Ophthalmology_ST/PhD/MiSeq/DoubleExpanded/allele_CTC_ref.csv"
 
# Output directory for Allele_1 and Allele_2 read ids
output_directory="/Users/shane/Library/CloudStorage/OneDrive-UniversityCollegeLondon/Medicine/Ophthalmology_ST/PhD/MiSeq/DoubleExpanded/TestOutput"
 
# Create the output directory if it doesn't exist
mkdir -p "$output_directory"
 
# Loop through all fastq files in the input folder
for input_fastq in "$input_folder"/*_R2_001.fastq; do
    # Check if the file is an R2 fastq file
    if [ ! -f "$input_fastq" ]; then
        echo "Skipping $input_fastq as it is not an R2 fastq file."
        continue
    fi
    # Extract mid (i.e. MiSeqID) part of the fastq file name
    file_name=$(basename "$input_fastq")
    mid_part=$(echo "$file_name" | awk -F'[-_]' '{print $1"-"$2"-"$3"-"$4}')
    # Match mid (i.e. MiSeqID) part with sample_key in the reference list
    sample_info=$(grep "$mid_part" "$reference_list")
 
    # Display the polymorphic CTC repeat in r2_allele_1_ctc and r2_allele_2_ctc columns
    r2_ctc_1=$(echo "$sample_info" | awk -F',' '{print $2}')
    r2_ctc_2=$(echo "$sample_info" | awk -F',' '{print $3}')    

    #Count the number of polymorphic CTC segment of the motif i.e. 6 or 4 etc. The awk -F'[\\[\\]]' '{print $3}' command is used to process the printed value. The -F'[\\[\\]]' option sets the field separator to either a "[" or a "]". This means that the string is split into fields wherever a "[" or a "]" is found. The print $3 command prints the third field, which is the number of repeats.
    repeat_count_1=$(echo "$r2_ctc_1" | awk -F'[\\[\\]]' '{print $3}')
    repeat_count_2=$(echo "$r2_ctc_2" | awk -F'[\\[\\]]' '{print $3}')

    # Display the results
    echo "Processing file: $input_fastq"
    echo "Sample Key: $mid_part"
    echo "sample_info: $sample_info"
    echo "r2_ctc_1: $r2_ctc_1"
    echo "r2_ctc_2: $r2_ctc_2"
    echo "repeat_count_1: $repeat_count_1"
    echo "repeat_count_2: $repeat_count_2"

    # Generate the dynamic sequence for Allele_1 i.e. AAGGAGnCAG. The printf 'GAG%.0s' $(seq "$repeat_count_1") command is used to generate the dynamic sequence. The seq "$repeat_count_1" command generates a sequence of numbers from 1 to the value of repeat_count_1. The printf 'GAG%.0s' command prints the string "GAG" the number of times specified by the sequence of numbers generated by the seq "$repeat_count_1" command. The %.0s option is used to specify that the string "GAG" is printed without a newline character.
    sequence_to_match_allele_1="AAG$(printf 'GAG%.0s' $(seq "$repeat_count_1"))CAG"
    # Generate the dynamic sequence for Allele_2 i.e. AAGGAGnCAG
    sequence_to_match_allele_2="AAG$(printf 'GAG%.0s' $(seq "$repeat_count_2"))CAG"

    # Output fastq file with r2_allele_1_ctc suffix
    output_fastq_allele_1="$output_directory/$(basename "${input_fastq%.fastq}")_CTC${repeat_count_1}.txt"
    # Output fastq file with r2_allele_2_ctc suffix
    output_fastq_allele_2="$output_directory/$(basename "${input_fastq%.fastq}")_CTC${repeat_count_2}.txt"

    #Extract matching sequences, write corresponding read id (i.e., first line for each group of 4 lines: NR % 4 == 1) without @ and "" 2:N.*"" for Allele_1.
    #awk: This command is used to process text files, and it is particularly powerful for working with structured text data.
    #-v seq="$sequence_to_match_allele_1": This part of the command defines an awk variable seq and sets its value to the content of the shell variable $sequence_to_match_allele_1. The -v flag is used to pass a shell variable to awk
    #'NR % 4 == 1 {header=$1; gsub(/^@| 2:N.*/, "", header); getline seq_line; if (seq_line ~ seq) print header}': This is the awk script itself, enclosed in single quotes. Let's break down the different parts:
        #NR % 4 == 1: This condition checks if the record number (NR) modulo 4 is equal to 1. In a FASTQ file, where each record consists of four lines, this condition selects only the first line of each record (header line).
        #{header=$1; gsub(/^@| 2:N.*/, "", header); getline seq_line; if (seq_line ~ seq) print header}:
            #header=$1;: It assigns the content of the first field (column) of the current line to the variable header. In a FASTQ file, this is the identifier line that starts with "@".
            #gsub(/^@| 2:N.*/, "", header);: This gsub function removes the leading "@" and any trailing " 2:N." from the header. The regular expression ^@| 2:N.* matches either the "@" at the beginning or the " 2:N." at the end of the line.
            #getline seq_line;: This command reads the next line (sequence line) and stores it in the variable seq_line.
            #if (seq_line ~ seq) print header: It checks if seq_line contains the sequence stored in the seq variable. If it does, it prints the modified header. This is effectively selecting the read IDs for Allele_1 with the matching CTC allele.
    #"$input_fastq" > "$output_fastq_allele_1": Redirects the output of the awk command to a file specified by $output_fastq_allele_1.
    #In summary, this awk command processes a FASTQ file, extracts the read IDs for Allele_1 with a matching CTC allele, and writes the results to an output file.
    awk -v seq="$sequence_to_match_allele_1" 'NR % 4 == 1 {header=$1; gsub(/^@| 2:N.*/, "", header); getline seq_line; if (seq_line ~ seq) print header}' "$input_fastq" > "$output_fastq_allele_1"
    echo "Allele_1 matching sequences saved to: $output_fastq_allele_1"
    
    # Extract matching sequences, write correspondinng read id (i.e. first linefor each group of 4 lines: NR % 4 == 1) without @ and "" 2:N.*"" for Allele_2
    awk -v seq="$sequence_to_match_allele_2" 'NR % 4 == 1 {header=$1; gsub(/^@| 2:N.*/, "", header); getline seq_line; if (seq_line ~ seq) print header}' "$input_fastq" > "$output_fastq_allele_2"
    echo "Allele_2 matching sequences saved to: $output_fastq_allele_2"
    done